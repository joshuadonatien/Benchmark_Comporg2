#include <iostream>
#include <vector>
#include <fstream>
#include <chrono>
#include <random>
#include <algorithm>
#include <cmath>
using namespace std;
using namespace std::chrono;

// Constants for benchmark operations
const long long ADD_OPS = 1e10;   // 10^10 additions
const long long MUL_OPS = 5e9;    // 5 × 10^9 multiplications
const long long DIV_OPS = 2e9;    // 2 × 10^9 divisions
const long long MEM_OPS = 5e9;    // 5 × 10^9 memory operations
const long long FILE_SIZE = 1e9;  // 10^9 bytes (1GB)
const int SMALL_CHUNK = 100;      // 100 bytes per chunk
const int LARGE_CHUNK = 10000;    // 10000 bytes per chunk

void print_result(const string& name, double seconds) {
    cout << name << " Benchmark: " << seconds << " seconds" << endl;
}

void integer_benchmark() {
    auto start = high_resolution_clock::now();
    int a = 123456789, b = 987654321, c = 0;
    
    // Additions - 10^10 operations
    for (long long i = 0; i < ADD_OPS; i++) {
        c = a + b;
    }
    
    // Multiplications - 5 × 10^9 operations
    for (long long i = 0; i < MUL_OPS; i++) {
        c = a * b;
    }
    
    // Divisions - 2 × 10^9 operations
    for (long long i = 0; i < DIV_OPS; i++) {
        c = b / a;
    }
    
    auto end = high_resolution_clock::now();
    duration<double> elapsed = end - start;
    print_result("32-bit Integer", elapsed.count());
}

void float_benchmark() {
    auto start = high_resolution_clock::now();
    double a = 123456789.123456789, b = 987654321.987654321, c = 0.0;
    
    // Additions - 10^10 operations
    for (long long i = 0; i < ADD_OPS; i++) {
        c = a + b;
    }
    
    // Multiplications - 5 × 10^9 operations
    for (long long i = 0; i < MUL_OPS; i++) {
        c = a * b;
    }
    
    // Divisions - 2 × 10^9 operations
    for (long long i = 0; i < DIV_OPS; i++) {
        c = b / a;
    }
    
    auto end = high_resolution_clock::now();
    duration<double> elapsed = end - start;
    print_result("64-bit Floating Point", elapsed.count());
}

void memory_benchmark() {
    // Create a vector for memory operations
    // Assuming we can use a smaller array and cycle through it
    // to simulate 5 × 10^9 operations without using actual 5 × 10^9 elements
    const size_t array_size = 1000000; // Use 1M elements and cycle through them
    vector<int> memory_array(array_size);
    
    // Initialize random number generation
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<size_t> dis(0, array_size - 1);
    
    auto start = high_resolution_clock::now();
    
    // Memory reads - 5 × 10^9 operations
    int temp = 0;
    for (long long i = 0; i < MEM_OPS; i++) {
        size_t index = i % array_size; // Cycle through array instead of random access
        temp = memory_array[index];
    }
    
    // Memory writes - 5 × 10^9 operations
    for (long long i = 0; i < MEM_OPS; i++) {
        size_t index = i % array_size; // Cycle through array instead of random access
        memory_array[index] = i;
    }
    
    auto end = high_resolution_clock::now();
    duration<double> elapsed = end - start;
    print_result("Memory", elapsed.count());
}

void hd_benchmark(const string& filename, int chunk_size) {
    vector<char> buffer(chunk_size, 'A');
    
    // Write file - 10^9 bytes, chunk_size bytes at a time
    ofstream outfile(filename, ios::binary);
    if (!outfile) {
        cerr << "Failed to open file for writing: " << filename << endl;
        return;
    }

    auto start_write = high_resolution_clock::now();
    long long chunks_to_write = FILE_SIZE / chunk_size;
    for (long long i = 0; i < chunks_to_write; i++) {
        outfile.write(buffer.data(), chunk_size);
    }
    outfile.close();
    auto end_write = high_resolution_clock::now();
    
    // Read file - 10^9 bytes, chunk_size bytes at a time
    ifstream infile(filename, ios::binary);
    if (!infile) {
        cerr << "Failed to open file for reading: " << filename << endl;
        return;
    }